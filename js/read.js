Создал язык Брендо Эйк 1995
Js –– это интерпретируемый язык, компиллируемый в реальном времени через jit (just in time)
С var – обычная переменная, без var – глобальная. let – более современный вариант объявления переменной.
Области видимости: глобальная и локальная. 
'use strict' – строгий режим, код получается более чистый и безопасный. Многие современные фичи и функции работают в этом режиме по умолчанию.
Первый символ в переменной не должен быть цифрой. Допустимы символы в названии переменной $, _ .
Переменные чувствительны к регистру.
Разрешены нелатинские буквы, но не рекомендуются.
Без 'use strict' можно объявить переменную обычным присваиванием без let, но не рекомендуется.
Повторное объявление вызывает ошибку. Переменная может быть объявлена только один раз. Поэтому следует объявлять переменную только один раз и затем использовать её уже без let.
Существует список зарезервированных слов, которые нельзя использовать в качестве имён переменных, потому что они используются самим языком.
Константы с именами, записанными заглавными буквами, используются только как псевдонимы для «жёстко закодированных» значений.
Константа может быть инициализированна результатом какого-либо выражения, но значение должно быть присвоено сразу.
Двойные или одинарные кавычки являются «простыми», между ними нет разницы в JavaScript.
Обратные же кавычки имеют расширенную функциональность. Они позволяют нам встраивать выражения в строку, заключая их в ${…}. Например:
Математические операции в JavaScript «безопасны». Мы можем делать что угодно: делить на ноль, обращаться с нечисловыми строками как с числами и т.д.
Скрипт никогда не остановится с фатальной ошибкой (не «умрёт»). В худшем случае мы получим NaN как результат выполнения.



Зарезервированные ключевые слова в ECMAScript 2015
break
case
class
catch
const
continue
debugger
default
delete
do
else
export
extends
finally
for
function
if
import
in
instanceof
let
new
return
super
switch
this
throw
try
typeof
var
void
while
with
yield







Объявление переменных

let message;
message = 'Hello!';

alert(message); // показывает содержимое переменной



let message = 'Hello!'; // определяем переменную и присваиваем ей значение

alert(message); // Hello!


let user = 'John', age = 25, message = 'Hello';



let user = 'John';
let age = 25;
let message = 'Hello';


let user = 'John',
  age = 25,
  message = 'Hello';



let hello = 'Hello world!';

let message;

// копируем значение 'Hello world' из переменной hello в переменную message
message = hello;

// теперь две переменные содержат одинаковые данные
alert(hello); // Hello world!
alert(message); // Hello world!




Константы


const myBirthday = '18.04.1982';

Переменные, объявленные с помощью const, называются «константами». Их нельзя изменить. Попытка сделать это приведёт к ошибке:
const myBirthday = '18.04.1982';
myBirthday = '01.01.2001'; // ошибка, константу нельзя перезаписать!





Константы в верхнем регистре
Широко распространена практика использования констант в качестве псевдонимов для трудно запоминаемых значений, которые известны до начала исполнения скрипта.
const COLOR_RED = "#F00";
const COLOR_GREEN = "#0F0";
const COLOR_BLUE = "#00F";
const COLOR_ORANGE = "#FF7F00";

// ...когда нам нужно выбрать цвет
let color = COLOR_ORANGE;
alert(color); // #FF7F00

константы с именами, записанными заглавными буквами, используются только как псевдонимы для «жёстко закодированных» значений.




Типы данных

Js – динамически типизированный язык и переменные не привязаны к типам данных.
// Не будет ошибкой
let message = "hello";
message = 123456;

числа
Infinity представляет собой математическую бесконечность ∞. Это особое значение, которое больше любого числа.
Мы можем получить его в результате деления на ноль
NaN означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции, например:
Значение NaN «прилипчиво». Любая математическая операция с NaN возвращает NaN. (есть только одно исключение: NaN ** 0 равно 1).


В JavaScript есть 8 основных типов данных.

Семь из них называют «примитивными» типами данных:
number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).
bigint для целых чисел произвольной длины.
string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
boolean для true/false.
null представляет собой «ничего», «пусто» или «значение неизвестно».
undefined Специальное значение undefined также стоит особняком. Оно формирует тип из самого себя так же, как и null.
Оно означает, что «значение не было присвоено».
Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет undefined
Обычно null используется для присвоения переменной «пустого» или «неизвестного» значения, а undefined – для проверок, была ли переменная назначена.
symbol для уникальных идентификаторов.
И один не является «примитивным» и стоит особняком:
object для более сложных структур данных.

typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"  (1)

typeof null // "object"  (2)

typeof alert // "function"  (3)

BigInt
let n = (20 ** 20);
alert(typeof n);
alert (n);

// символ "n" в конце означает, что это BigInt
const bigInt = 1234567890123456789012345678901234567890n;



alert, prompt, confirm

alert
показывает сообщение.
prompt
показывает сообщение и запрашивает ввод текста от пользователя. Возвращает напечатанный в поле ввода текст или null, если была нажата кнопка «Отмена» или Esc с клавиатуры.
confirm
показывает сообщение и ждёт, пока пользователь нажмёт OK или Отмена. Возвращает true, если нажата OK, и false, если нажата кнопка «Отмена» или Esc с клавиатуры.
Все эти методы являются модальными: останавливают выполнение скриптов и не позволяют пользователю взаимодействовать с остальной частью страницы до тех пор, пока окно не будет закрыто.

На все указанные методы распространяются два ограничения:

Расположение окон определяется браузером. Обычно окна находятся в центре.
Визуальное отображение окон зависит от браузера, и мы не можем изменить их вид.




Преобразование типов

Чаще всего операторы и функции автоматически приводят переданные им значения к нужному типу.
Например, alert автоматически преобразует любое значение к строке. Математические операторы преобразуют значения к числам.

Строковое преобразование
Строковое преобразование происходит, когда требуется представление чего-либо в виде строки.

Например, alert(value) преобразует значение к строке.

Также мы можем использовать функцию String(value), чтобы преобразовать значение к строке:

let value = true;
alert(typeof value); // boolean

value = String(value); // теперь value это строка "true"
alert(typeof value); // string
Преобразование происходит очевидным образом. false становится "false", null становится "null" и т.п.


Численное преобразование
Численное преобразование происходит в математических функциях и выражениях.

Например, когда операция деления / применяется не к числу:

alert( "6" / "2" ); // 3, строки преобразуются в числа
Мы можем использовать функцию Number(value), чтобы явно преобразовать value к числу:

let str = "123";
alert(typeof str); // string

let num = Number(str); // становится числом 123

alert(typeof num); // number
Явное преобразование часто применяется, когда мы ожидаем получить число из строкового контекста, например из текстовых полей форм.

Если строка не может быть явно приведена к числу, то результатом преобразования будет NaN. Например:

let age = Number("Любая строка вместо числа");

alert(age); // NaN, преобразование не удалось
Правила численного преобразования:

Значение	Преобразуется в…
undefined	NaN
null	0
true / false	1 / 0
string	Пробельные символы (пробелы, знаки табуляции \t, знаки новой строки \n и т. п.) по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.
Примеры:

alert( Number("   123   ") ); // 123
alert( Number("123z") );      // NaN (ошибка чтения числа на месте символа "z")
alert( Number(true) );        // 1
alert( Number(false) );       // 0

null и undefined ведут себя по-разному. Так, null становится нулём, тогда как undefined приводится к NaN.


Логическое преобразование

Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false.
Все остальные значения становятся true.
alert( Boolean(1) ); // true
alert( Boolean(0) ); // false

alert( Boolean("Привет!") ); // true
alert( Boolean("") ); // false

alert( Boolean("0") ); // true
alert( Boolean(" ") ); // пробел это тоже true (любая непустая строка это true)




let age = prompt('Сколько тебе лет?', 100);
alert(`Тебе ${age} лет!`);



 let name = "Ilya";

alert( `hello ${1}` ); // ?

alert( `hello ${"name"}` ); // ?

alert( `hello ${name}` ); // ?»


let isBoss = confirm("Ты здесь главный?");
alert(isBoss);


let currentUserName = prompt('Как тебя зовут?', "");
alert(`Его имя – ${currentUserName}`);




let a = prompt('Первое число', 1);
let b = prompt('Второе число', 2);

alert(+a + +b);



let questionNameJs = prompt('Какое правильное название JavaScript?', "");

if (questionNameJs == 'ECMAScript') {
	alert('Верно!');
} else {
	alert('Неа(');
}




let userValue = prompt('Введите какое-либо значение', '0');

if (userValue > 0) {
	alert(+1);
} else if (userValue == 0) {
	alert('значение равно нулу');
} else {
	alert(-1);
}



if (1 && 0) {
	alert('Это не должно быть выведено на экран');
}









let height = null;
let width = null;
// ...сработает вот так (совсем не как нам нужно):
let area = height ?? (100 * width) ?? 50;



let i = 0;
while (i < 3) {
	alert(i);
	i++;
}


let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);


let i = 0;

for (; i < 3;) {
  alert( i++ );
}




for (let i=2; i <= 10; i++) {
	if (i % 2 == 0) {
	alert(i);
  }
}




Задание: Напишите цикл, который предлагает prompt ввести число, большее 100. Если посетитель ввёл другое число – попросить ввести ещё раз, и так далее.

Цикл должен спрашивать число пока либо посетитель не введёт число, большее 100, либо не нажмёт кнопку Отмена (ESC).

Предполагается, что посетитель вводит только числа. Предусматривать обработку нечисловых строк в этой задаче необязательно.


let i;
do {
	i = prompt('Введите число > 100', '');
}
while (i !== null && i < 100);
alert(`Ты ввел число ${i}! И это правильный ответ`);


let i=prompt('Введите число > 100', '');

while (i !== null && i <= 100) {
	i=prompt('Давай-ка по-внимательнее прочтем задание');
}
alert(`Ты ввел число ${i}! И это правильный ответ`);




let i = prompt('Введите число > 100', '');

while (i !== null && i <= 100) {
  i = prompt('Давай-ка по-внимательнее прочтем задание');
}

if (i !== null) {
  alert(`Ты ввел число ${i}! И это правильный ответ`);
} else {
  alert('Вы отменили ввод.');
}





Вывести простые числа
let n = 100;
nextPrime:
for (let i = 2; i <= n; i++) {
	for (let j = 2; j < i; j++) {
		if (i % j === 0) continue nextPrime;
	}
	alert(i);
}





let arg = prompt("Введите число?");
switch (arg) {
  case '0':
  case '1':
    alert( 'Один или ноль' );
    break;

  case '2':
    alert( 'Два' );
    break;

  case 3:
    alert( 'Никогда не выполнится!' );
    break;
  default:
    alert( 'Неизвестное значение' );
}




let userName = "Василий";

function showMessage() {
 let message = "Hello, my dear " + userName + '!';

	alert(message);
}
showMessage();




let userName = 'Василий';

function showMessage() {
	let userName = 'Петр';
	let message = 'Привет, ' + userName + '!';
	alert(message);
}

showMessage();
alert(userName);



function sum(a, b) {
  return a + b;
}
let result = sum(1, 2);
alert( result );


Пример 22
function checkAge(age) {
  if (age >= 18) {
    return true;
  } else {
    return confirm('А родители разрешили?');
  }
}

let age = prompt('Сколько вам лет?', 18);

if ( checkAge(age) ) {
  alert( 'Доступ получен' );
} else {
  alert( 'Доступ закрыт' );
}


Пример 23
function showMovie(age) {
  if ( !checkAge(age) ) {
    return;
  }

  alert( "Вам показывается кино" ); // (*)
  // ...
}






function showPrimes(n) {
  nextPrime: for (let i = 2; i < n; i++) {

    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert( i ); // простое
  }
}
Второй вариант использует дополнительную функцию isPrime(n) для проверки на простое:

function showPrimes(n) {

  for (let i = 2; i < n; i++) {
    if (!isPrime(i)) continue;

    alert(i);  // простое
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if ( n % i == 0) return false;
  }
  return true;
}









Перепишите функцию, используя оператор '?' или '||'
важность: 4
Следующая функция возвращает true, если параметр age больше 18.

В ином случае она задаёт вопрос confirm и возвращает его результат.

function checkAge(age) {
  if (age > 18) {
    return true;
  } else {
    return confirm('Родители разрешили?');
  }
}
Перепишите функцию, чтобы она делала то же самое, но без if, в одну строку.

Сделайте два варианта функции checkAge:

Используя оператор ?
Используя оператор ||


let age = prompt('How older you?');
function checkAge(age) {
	return (age > 18) ? alert('Добро пожаловать!') : confirm('Родители-то разрешили?');
}

checkAge(age);


let age = prompt('How older you?');

function checkAge(age) {
	return (age > 18) || confirm('Родители разрешили?');
}







Написать функцию, которая возвращает меньшее из двух чисел

let min_a = +prompt('Введите число №1', ' ');
let min_b = +prompt('Введите число №2', ' ');

function minNumber(num_a, num_b) {
	return (num_a < num_b) ? `Число ${num_a} > числа ${min_b}` : num_b;
}

alert(minNumber(min_a, min_b));


let num_exp_1 = +prompt('Введите число, которое будет возведено в степень', '4');
let num_exp_2 = +prompt('Введите степень', '2');

function exponentiation(num_exp_1, num_exp_2) {
	return `Число ${num_exp_1}, возведенное в степень ${num_exp_2} = ${num_exp_1 ** num_exp_2}`;
}

alert(exponentiation(num_exp_1, num_exp_2));



let num_exp_1 = +prompt('Введите число, которое будет возведено в степень', '4');
let num_exp_2 = +prompt('Введите степень', '2');

function exponentiation(num_exp_1, num_exp_2) {
	if (Number(num_exp_1) && Number(num_exp_2)) {
		return `Число ${num_exp_1}, возведенное в степень ${num_exp_2} = ${num_exp_1 ** num_exp_2}`;
	} else {
		alert('Нужны числа, а не буквы!');
	}
}

	if (exponentiation(num_exp_1, num_exp_2)) {
		alert(exponentiation(num_exp_1, num_exp_2));	
	} 



function pow(x, n) {
  let result = x;

  for (let i = 1; i < n; i++) {
    result *= x;
  }

  return result;
}

let x = prompt("x?", '');
let n = prompt("n?", '');

if (n >= 1 && n % 1 == 0) {
  alert( pow(x, n) );
} else {
  alert(`Степень ${n} не поддерживается, используйте натуральное число`);
}





function sayHi() {
	alert('Hi');
}

let function_link = sayHi;

sayHi();
function_link();




Пример 25
function ask(question, yes, no) {
	if (confirm(question)) {
		yes();
	} else {
		no();
	}
}

function showOk() {
	alert('Вы дали согласие!');
}

function showCancel() {
	alert('Вы не согласны!');
}

ask('Вы согласны?', showOk, showCancel);





Пример 25_1
function ask(question, yes, no) {
	if (confirm(question)) {
		yes();
	} else {
		no();
	}
}

ask('Вы даете свое согласие?',
	function() { alert('Вы дали свое согласие!'); },
	function() { alert('Вы не дали свое согласие!'); }
	);


























































































































