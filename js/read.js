Создал язык Брендо Эйк 1995
Js –– это интерпретируемый язык, компиллируемый в реальном времени через jit (just in time)
С var – обычная переменная, без var – глобальная. let – более современный вариант объявления переменной.
Области видимости: глобальная и локальная. 
'use strict' – строгий режим, код получается более чистый и безопасный. Многие современные фичи и функции работают в этом режиме по умолчанию.
Первый символ в переменной не должен быть цифрой. Допустимы символы в названии переменной $, _ .
Переменные чувствительны к регистру.
Разрешены нелатинские буквы, но не рекомендуются.
Без 'use strict' можно объявить переменную обычным присваиванием без let, но не рекомендуется.
Повторное объявление вызывает ошибку. Переменная может быть объявлена только один раз. Поэтому следует объявлять переменную только один раз и затем использовать её уже без let.
Существует список зарезервированных слов, которые нельзя использовать в качестве имён переменных, потому что они используются самим языком.
Константы с именами, записанными заглавными буквами, используются только как псевдонимы для «жёстко закодированных» значений.
Константа может быть инициализированна результатом какого-либо выражения, но значение должно быть присвоено сразу.
Двойные или одинарные кавычки являются «простыми», между ними нет разницы в JavaScript.
Обратные же кавычки имеют расширенную функциональность. Они позволяют нам встраивать выражения в строку, заключая их в ${…}. Например:
Математические операции в JavaScript «безопасны». Мы можем делать что угодно: делить на ноль, обращаться с нечисловыми строками как с числами и т.д.
Скрипт никогда не остановится с фатальной ошибкой (не «умрёт»). В худшем случае мы получим NaN как результат выполнения.



Зарезервированные ключевые слова в ECMAScript 2015
break
case
class
catch
const
continue
debugger
default
delete
do
else
export
extends
finally
for
function
if
import
in
instanceof
let
new
return
super
switch
this
throw
try
typeof
var
void
while
with
yield







Объявление переменных

let message;
message = 'Hello!';

alert(message); // показывает содержимое переменной



let message = 'Hello!'; // определяем переменную и присваиваем ей значение

alert(message); // Hello!


let user = 'John', age = 25, message = 'Hello';



let user = 'John';
let age = 25;
let message = 'Hello';


let user = 'John',
  age = 25,
  message = 'Hello';



let hello = 'Hello world!';

let message;

// копируем значение 'Hello world' из переменной hello в переменную message
message = hello;

// теперь две переменные содержат одинаковые данные
alert(hello); // Hello world!
alert(message); // Hello world!




Константы


const myBirthday = '18.04.1982';

Переменные, объявленные с помощью const, называются «константами». Их нельзя изменить. Попытка сделать это приведёт к ошибке:
const myBirthday = '18.04.1982';
myBirthday = '01.01.2001'; // ошибка, константу нельзя перезаписать!





Константы в верхнем регистре
Широко распространена практика использования констант в качестве псевдонимов для трудно запоминаемых значений, которые известны до начала исполнения скрипта.
const COLOR_RED = "#F00";
const COLOR_GREEN = "#0F0";
const COLOR_BLUE = "#00F";
const COLOR_ORANGE = "#FF7F00";

// ...когда нам нужно выбрать цвет
let color = COLOR_ORANGE;
alert(color); // #FF7F00

константы с именами, записанными заглавными буквами, используются только как псевдонимы для «жёстко закодированных» значений.




Типы данных

Js – динамически типизированный язык и переменные не привязаны к типам данных.
// Не будет ошибкой
let message = "hello";
message = 123456;

числа
Infinity представляет собой математическую бесконечность ∞. Это особое значение, которое больше любого числа.
Мы можем получить его в результате деления на ноль
NaN означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции, например:
Значение NaN «прилипчиво». Любая математическая операция с NaN возвращает NaN. (есть только одно исключение: NaN ** 0 равно 1).


В JavaScript есть 8 основных типов данных.

Семь из них называют «примитивными» типами данных:
number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).
bigint для целых чисел произвольной длины.
string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
boolean для true/false.
null представляет собой «ничего», «пусто» или «значение неизвестно».
undefined Специальное значение undefined также стоит особняком. Оно формирует тип из самого себя так же, как и null.
Оно означает, что «значение не было присвоено».
Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет undefined
Обычно null используется для присвоения переменной «пустого» или «неизвестного» значения, а undefined – для проверок, была ли переменная назначена.
symbol для уникальных идентификаторов.
И один не является «примитивным» и стоит особняком:
object для более сложных структур данных.

typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"  (1)

typeof null // "object"  (2)

typeof alert // "function"  (3)

BigInt
let n = (20 ** 20);
alert(typeof n);
alert (n);

// символ "n" в конце означает, что это BigInt
const bigInt = 1234567890123456789012345678901234567890n;



alert, prompt, confirm

alert
показывает сообщение.
prompt
показывает сообщение и запрашивает ввод текста от пользователя. Возвращает напечатанный в поле ввода текст или null, если была нажата кнопка «Отмена» или Esc с клавиатуры.
confirm
показывает сообщение и ждёт, пока пользователь нажмёт OK или Отмена. Возвращает true, если нажата OK, и false, если нажата кнопка «Отмена» или Esc с клавиатуры.
Все эти методы являются модальными: останавливают выполнение скриптов и не позволяют пользователю взаимодействовать с остальной частью страницы до тех пор, пока окно не будет закрыто.

На все указанные методы распространяются два ограничения:

Расположение окон определяется браузером. Обычно окна находятся в центре.
Визуальное отображение окон зависит от браузера, и мы не можем изменить их вид.




Преобразование типов

Чаще всего операторы и функции автоматически приводят переданные им значения к нужному типу.
Например, alert автоматически преобразует любое значение к строке. Математические операторы преобразуют значения к числам.

Строковое преобразование
Строковое преобразование происходит, когда требуется представление чего-либо в виде строки.

Например, alert(value) преобразует значение к строке.

Также мы можем использовать функцию String(value), чтобы преобразовать значение к строке:

let value = true;
alert(typeof value); // boolean

value = String(value); // теперь value это строка "true"
alert(typeof value); // string
Преобразование происходит очевидным образом. false становится "false", null становится "null" и т.п.


Численное преобразование
Численное преобразование происходит в математических функциях и выражениях.

Например, когда операция деления / применяется не к числу:

alert( "6" / "2" ); // 3, строки преобразуются в числа
Мы можем использовать функцию Number(value), чтобы явно преобразовать value к числу:

let str = "123";
alert(typeof str); // string

let num = Number(str); // становится числом 123

alert(typeof num); // number
Явное преобразование часто применяется, когда мы ожидаем получить число из строкового контекста, например из текстовых полей форм.

Если строка не может быть явно приведена к числу, то результатом преобразования будет NaN. Например:

let age = Number("Любая строка вместо числа");

alert(age); // NaN, преобразование не удалось
Правила численного преобразования:

Значение	Преобразуется в…
undefined	NaN
null	0
true / false	1 / 0
string	Пробельные символы (пробелы, знаки табуляции \t, знаки новой строки \n и т. п.) по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.
Примеры:

alert( Number("   123   ") ); // 123
alert( Number("123z") );      // NaN (ошибка чтения числа на месте символа "z")
alert( Number(true) );        // 1
alert( Number(false) );       // 0

null и undefined ведут себя по-разному. Так, null становится нулём, тогда как undefined приводится к NaN.


Логическое преобразование

Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false.
Все остальные значения становятся true.
alert( Boolean(1) ); // true
alert( Boolean(0) ); // false

alert( Boolean("Привет!") ); // true
alert( Boolean("") ); // false

alert( Boolean("0") ); // true
alert( Boolean(" ") ); // пробел это тоже true (любая непустая строка это true)




let age = prompt('Сколько тебе лет?', 100);
alert(`Тебе ${age} лет!`);



 let name = "Ilya";

alert( `hello ${1}` ); // ?

alert( `hello ${"name"}` ); // ?

alert( `hello ${name}` ); // ?»


let isBoss = confirm("Ты здесь главный?");
alert(isBoss);


let currentUserName = prompt('Как тебя зовут?', "");
alert(`Его имя – ${currentUserName}`);



Базовые операторы
Термины: «унарный», «бинарный», «операнд»
Операнд – то, к чему применяется оператор. Например, в умножении 5 * 2 есть два операнда: левый операнд равен 5, а правый операнд равен 2. Иногда их называют «аргументами» вместо «операндов».
Унарным называется оператор, который применяется к одному операнду. Например, оператор унарный минус "-" меняет знак числа на противоположный:

let x = 1;

x = -x;
alert( x ); // -1, применили унарный минус
Бинарным называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме:

let x = 1, y = 3;
alert( y - x ); // 2, бинарный минус вычитает значения

alert( 5 % 2 ); // 1, остаток от деления 5 на 2
alert( 8 % 3 ); // 2, остаток от деления 8 на 3
alert( 8 % 4 ); // 0, остаток от деления 8 на 4
Возведение в степень **
Оператор возведения в степень a ** b возводит a в степень b.


Сложение строк при помощи бинарного +
let s = "моя" + "строка";
alert(s); // моястрока
Обратите внимание, если хотя бы один операнд является строкой, то второй будет также преобразован в строку.
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
alert(2 + 2 + '1' ); // будет "41", а не "221"

Сложение и преобразование строк — это особенность бинарного плюса +. Только + может работать со строками. Другие арифметические операторы работают только с числами и всегда преобразуют операнды в числа.
Если операнд не число, унарный плюс преобразует его в число.
// Не влияет на числа
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

// Преобразует не числа в числа
alert( +true ); // 1
alert( +"" );   // 0
это то же самое, что и Number(...), только короче.
let apples = "2";
let oranges = "3";

alert( apples + oranges ); // "23", так как бинарный плюс объединяет строки
Поэтому используем унарный плюс, чтобы преобразовать к числу:
let apples = "2";
let oranges = "3";

// оба операнда предварительно преобразованы в числа
alert( +apples + +oranges ); // 5

let a = prompt('Первое число', 1);
let b = prompt('Второе число', 2);

alert(+a + +b);


// более длинный вариант
// alert( Number(apples) + Number(oranges) ); // 5

Приоритет	Тип оператора	Ассоциативность	Конкретные операторы
18	Группировка	не определено	( … )
17	Доступ к свойствам	слева направо	… . …
Доступ к свойствам с возможностью вычисления	… [ … ]
new (со списком аргументов)	не определено	new … ( … )
Вызов функции	слева направо	… ( … )
Оператор опциональной последовательности (?.)	?.
16	new (без списка аргументов)	справа налево	new …
15	Постфиксный инкремент	не определено	… ++
Постфиксный декремент	… --
14	Логическое отрицание (!)	справа налево	! …
Побитовое отрицание (~)	~ …
Унарный плюс	+ …
Унарный минус	- …
Префиксный инкремент	++ …
Префиксный декремент	-- …
typeof	typeof …
void	void …
delete	delete …
await	await …
13	Возведение в степень (**)	справа налево	… ** …
12	Умножение (*)	слева направо	… * …
Деление (/)	… / …
Остаток от деления (%)	… % …
11	Сложение (+)	слева направо	… + …
Вычитание (-)	… - …
10	Побитовый сдвиг влево (<<)	слева направо	… << …
Побитовый сдвиг вправо (>>)	… >> …
Сдвиг вправо с заполнением нулей (>>>)	… >>> …
9	Меньше (<)	слева направо	… < …
Меньше или равно (<=)	… <= …
Больше (>)	… > …
Больше или равно (>=)	… >= …
in	… in …
instanceof	… instanceof …
8	Равенство (==)	слева направо	… == …
Неравенство (!=)	… != …
Строгое равенство (===)	… === …
Строгое неравенство (!==)	… !== …
7	Побитовое «И» (&)	слева направо	… & …
6	Побитовое исключающее «ИЛИ» (^)	слева направо	… ^ …
5	Побитовое «ИЛИ» (|)	слева направо	… | …
4	Логическое «И» (&&)	слева направо	… && …
3	Логическое «ИЛИ» (||)	слева направо	… || …
Оператор нулевого слияния (??)	… ?? …
2	Присваивание	справа налево	… = …
… += …
… -= …
… **= …
… *= …
… /= …
… %= …
… <<= …
… >>= …
… >>>= …
… &= …
… ^= …
… |= …
… &&= …
… ||= …
… ??= …
Условный (тернарный) оператор	справа налево	… ? … : …
yield	справа налево	yield …
yield*	yield* …
1	Запятая / Последовательность	слева направо	… , …


Инкремент/декремент
Инкремент/декремент можно применить только к переменной. Попытка использовать его на значении, типа 5++, приведёт к ошибке.
let counter = 1;
let a = ++counter; // (*)

alert(a); // 2
В строке (*) префиксная форма ++counter увеличивает counter и возвращает новое значение 2. Так что alert покажет 2.

Теперь посмотрим на постфиксную форму:

let counter = 1;
let a = counter++; // (*) меняем ++counter на counter++

alert(a); // 1
В строке (*) постфиксная форма counter++ также увеличивает counter, но возвращает старое значение (которое было до увеличения). Так что alert покажет 1.
Операторы ++/-- могут также использоваться внутри выражений. Их приоритет выше, чем у большинства других арифметических операций.

let a = 1, b = 1;

let c = ++a; // ?
let d = b++; // ?
Ответ:

a = 2
b = 2
c = 2
d = 1
let a = 1, b = 1;

alert( ++a ); // 2, префиксная форма возвращает новое значение
alert( b++ ); // 1, постфиксная форма возвращает старое значение

alert( a ); // 2, значение увеличено один раз
alert( b ); // 2, значение увеличено один раз


Побитовые операторы
Побитовые операторы работают с 32-разрядными целыми числами (при необходимости приводят к ним), на уровне их внутреннего двоичного представления.

Эти операторы не являются чем-то специфичным для JavaScript, они поддерживаются в большинстве языков программирования.

Поддерживаются следующие побитовые операторы:

AND(и) ( & )
OR(или) ( | )
XOR(побитовое исключающее или) ( ^ )
NOT(не) ( ~ )
LEFT SHIFT(левый сдвиг) ( << )
RIGHT SHIFT(правый сдвиг) ( >> )
ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( >>> )
Они используются редко, когда возникает необходимость оперировать с числами на очень низком (побитовом) уровне. В ближайшем времени они нам не понадобятся, так как веб-разработчики редко к ним прибегают, хотя в некоторых сферах (например, в криптографии) они полезны


задачи
"" + 1 + 0 = "10" // (1)
"" - 1 + 0 = -1 // (2)
true + false = 1
6 / "3" = 2
"2" * "3" = 6
4 + 5 + "px" = "9px"
"$" + 4 + 5 = "$45"
"4" - 2 = 2
"4px" - 2 = NaN
"  -9  " + 5 = "  -9  5" // (3)
"  -9  " - 5 = -14 // (4)
null + 1 = 1 // (5)
undefined + 1 = NaN // (6)
" \t \n" - 2 = -2 // (7)
Сложение со строкой "" + 1 преобразует 1 к строке: "" + 1 = "1", и в следующем случае "1" + 0 работает то же самое правило.
Вычитание - (как и большинство математических операторов) работает только с числами, пустая строка "" приводится к 0.
Сложение со строкой превращает число 5 в строку и добавляет к строке.
Вычитание всегда преобразует к числу, значит строка " -9 " становится числом -9 (пробелы по краям обрезаются).
null становится 0 после численного преобразования.
undefined становится NaN после численного преобразования.
Пробельные символы, такие как \t и \n, по краям строки игнорируются при преобразовании в число, так что строка " \t \n", аналогично пустой строке, становится 0 после численного преобразования.


Сравнения
alert( 2 > 1 );  // true (верно)
alert( 2 == 1 ); // false (неверно)
alert( 2 != 1 ); // true (верно)
Сравнение строк
Чтобы определить, что одна строка больше другой, JavaScript использует «алфавитный» или «лексикографический» порядок.
Используется кодировка Unicode, а не настоящий алфавит
Приведённый выше алгоритм сравнения похож на алгоритм, используемый в словарях и телефонных книгах, но между ними есть и различия.
Например, в JavaScript имеет значение регистр символов. Заглавная буква "A" не равна строчной "a". Какая же из них больше? Строчная "a". Почему? Потому что строчные буквы имеют больший код во внутренней таблице кодирования, которую использует JavaScript (Unicode).


Сравнение разных типов
При сравнении значений разных типов JavaScript приводит каждое из них к числу.

Например:

alert( '2' > 1 ); // true, строка '2' становится числом 2
alert( '01' == 1 ); // true, строка '01' становится числом 1

Логическое значение true становится 1, а false – 0.
Например:

alert( true == 1 ); // true
alert( false == 0 ); // true

let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true строка не пустая

alert(a == b); // true!
С точки зрения JavaScript, результат ожидаем. Равенство преобразует значения, используя числовое преобразование, поэтому "0" становится 0. В то время как явное преобразование с помощью Boolean использует другой набор правил.


Строгое сравнение
Использование обычного сравнения == может вызывать проблемы. Например, оно не отличает 0 от false:
alert( 0 == false ); // true
Та же проблема с пустой строкой:
alert( '' == false ); // true

alert( 0 === false ); // false, так как сравниваются разные типы
оператор строгого неравенства !==


Сравнение с null и undefined
Поведение null и undefined при сравнении с другими значениями — особое:

При строгом равенстве ===
Эти значения различны, так как различны их типы.

alert( null === undefined ); // false
При нестрогом равенстве ==
Эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.

alert( null == undefined ); // true

При использовании математических операторов и других операторов сравнения < > <= >=
Значения null/undefined преобразуются к числам: null становится 0, а undefined – NaN.
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true

Значение undefined несравнимо с другими значениями.
undefined всегда преобразуется в NaN.

alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)

задачи
5 > 4 → true
"ананас" > "яблоко" → false
"2" > "12" → true
undefined == null → true
undefined === null → false
null == "\n0\n" → false
null === +"\n0\n" → false
Разъяснения:

Очевидно, true.
Используется посимвольное сравнение, поэтому false. "а" меньше, чем "я".
Снова посимвольное сравнение. Первый символ первой строки "2" больше, чем первый символ второй "1".
Специальный случай. Значения null и undefined равны только друг другу при нестрогом сравнении.
Строгое сравнение разных типов, поэтому false.
Аналогично (4), null равен только undefined.
Строгое сравнение разных типов.



Условие if
let accessAllowed;
let age = prompt('Сколько вам лет?', '');

if (age > 18) {
  accessAllowed = true;
} else {
  accessAllowed = false;
}
alert(accessAllowed);

тернарный оператор:
let result = условие ? значение1 : значение2;
let accessAllowed = (age > 18) ? true : false;
// оператор сравнения "age > 18" выполняется первым в любом случае
// (нет необходимости заключать его в скобки)
let accessAllowed = age > 18 ? true : false;


let age = prompt('Возраст?', 18);

let message = (age < 3) ? 'Здравствуй, малыш!' :
  (age < 18) ? 'Привет!' :
  (age < 100) ? 'Здравствуйте!' :
  'Какой необычный возраст!';
alert( message );


задачи
if ("0") {
  alert( 'Привет' );//true
}


Логические операторы
могут применяться к значениям любых типов.
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false


let hour = 12;
let isWeekend = true;

if (hour < 10 || hour > 18 || isWeekend) {
  alert( 'Офис закрыт.' ); // это выходной
}

Оператор || выполняет следующие действия:

Вычисляет операнды слева направо.
Каждый операнд конвертирует в логическое значение. Если результат true, останавливается и возвращает исходное значение этого операнда.
Если все операнды являются ложными (false), возвращает последний из них.
Значение возвращается в исходном виде, без преобразования.

Другими словами, цепочка ИЛИ || возвращает первое истинное значение или последнее ложное или последнее истинное, если такое значение не найдено.
alert( 1 || 0 ); // 1 (1 - истинное значение)
alert( true || 'какая-то строка' ); // true

alert( null || 1 ); // 1 (первое истинное значение)
alert( null || 0 || 1 ); // 1 (первое истинное значение)
alert( undefined || null || 0 ); // 0 (поскольку все ложно, возвращается последнее значение)

||= (Логическое присваивание ИЛИ)
Новая возможность
Эта возможность была добавлена в язык недавно. В старых браузерах может понадобиться полифил.

a ||= b;
Оператор ||= принимает два операнда и выполняет следующие действия:

Вычисляет операнды слева направо.
Конвертирует a в логическое значение.
Если a ложно, присваивает a значение b.


&& (И)
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
Возвращает первое значение false или последнее значение true
Заточен на поиск false
Приоритет у него выше, чем у ||
Вычисляет операнды слева направо.
Каждый операнд преобразует в логическое значение. Если результат false, останавливается и возвращает исходное значение этого операнда.
Если все операнды были истинными, возвращается последний.

// Если первый операнд истинный,
// И возвращает второй:
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5

// Если первый операнд ложный,
// И возвращает его. Второй операнд игнорируется
alert( null && 5 ); // null
alert( 0 && "какая-то строка" ); // 0
alert( 1 && 2 && null && 3 ); // null
alert( 1 && 2 && 3 ); // 3


&&= (Логическое присваивание И)
&&= присвоит a значение b только в том случае, если a истинно.
let greeting = "Привет"; // строка непустая, поэтому будет преобразована к логическому значению true оператором &&=
greeting &&= greeting + ", пользователь!"; // то же самое, что true && (greeting = greeting + "...")
alert( greeting ) // "Привет, пользователь!"


! (НЕ)
Оператор принимает один аргумент и выполняет следующие действия:

Сначала приводит аргумент к логическому типу true/false.
Затем возвращает противоположное значение.
Например:

alert( !true ); // false
alert( !0 ); // true
В частности, двойное НЕ !! используют для преобразования значений к логическому типу:

alert( !!"непустая строка" ); // true
alert( !!null ); // false
То есть первое НЕ преобразует значение в логическое значение и возвращает обратное, а второе НЕ снова инвертирует его. В конце мы имеем простое преобразование значения в логическое.

задачи
alert( null || 2 || undefined );

Что выведет alert (ИЛИ)?
важность: 3

alert( alert(1) || 2 || alert(3) );
решение
Ответ: сначала 1, затем 2.

alert( alert(1) || 2 || alert(3) );
Вызов alert не возвращает значения, или, иначе говоря, возвращает undefined.

Первый оператор ИЛИ || выполнит первый alert(1).
Получит undefined и пойдёт дальше, ко второму операнду в поисках истинного значения.
Так как второй операнд 2 является истинным, то вычисления завершатся, результатом undefined || 2 будет 2, которое будет выведено внешним alert( .... ).
Второй оператор || не будет выполнен, выполнение до alert(3) не дойдёт, поэтому 3 выведено не будет.


Что выведет код ниже?

alert( 1 && null && 2 );
решение
Ответ: null, потому что это первое «ложное» значение из списка.

alert( 1 && null && 2 );

Что выведет код ниже?

alert( alert(1) && alert(2) );
решение
Ответ: 1, а затем undefined.

alert( alert(1) && alert(2) );
Вызов alert не возвращает значения, или, иначе говоря, возвращает undefined.

Поэтому до правого alert дело не дойдёт, вычисления закончатся на левом.


Что выведет код ниже?

alert( null || 2 && 3 || 4 );
решение
Ответ: 3.

alert( null || 2 && 3 || 4 );
Приоритет оператора && выше, чем ||, поэтому он выполнится первым.

Результат 2 && 3 = 3, поэтому выражение приобретает вид:

null || 3 || 4
Теперь результатом является первое истинное значение: 3.

Что выведет код ниже?

let value = NaN;

value &&= 10;
value ||= 20;
value &&= 30;
value ||= 40;

alert(value);
решение
Ответ: 30.


Напишите условие if для проверки, что переменная age находится в диапазоне между 14 и 90 включительно.
«Включительно» означает, что значение переменной age может быть равно 14 или 90.
решение
if (age >= 14 && age <= 90)

Напишите условие if для проверки, что значение переменной age НЕ находится в диапазоне 14 и 90 включительно.
Напишите два варианта: первый с использованием оператора НЕ !, второй – без этого оператора.
решение
Первый вариант:

if (!(age >= 14 && age <= 90))
закон де Моргана !(a && b) -> !a || !b
				 !(a || b) -> !a && !b
Второй вариант:
if (age < 14 || age > 90)

Какие из перечисленных ниже alert выполнятся?
Какие конкретно значения будут результатами выражений в условиях if(...)?

if (-1 || 0) alert( 'first' );
if (-1 && 0) alert( 'second' );
if (null || -1 && 1) alert( 'third' );
решение
Ответ: первое и третье выполнятся.

Подробности:

// Выполнится.
// Результат -1 || 0 = -1, в логическом контексте true
if (-1 || 0) alert( 'first' );

// Не выполнится
// -1 && 0 = 0,  в логическом контексте false
if (-1 && 0) alert( 'second' );

// Выполнится
// оператор && имеет больший приоритет, чем ||
// так что -1 && 1 выполнится раньше
// вычисления: null || -1 && 1  ->  null || 1  ->  1
if (null || -1 && 1) alert( 'third' );


Напишите код, который будет спрашивать логин с помощью prompt.
Если посетитель вводит «Админ», то prompt запрашивает пароль, если ничего не введено или нажата клавиша Esc – показать «Отменено», в противном случае отобразить «Я вас не знаю».
Пароль проверять так:
Если введён пароль «Я главный», то выводить «Здравствуйте!»,
Иначе – «Неверный пароль»,
При отмене или в случае если ничего не введено – «Отменено».
Для решения используйте вложенные блоки if. Обращайте внимание на стиль и читаемость кода.

Подсказка: передача пустого ввода в приглашение prompt возвращает пустую строку ''. Нажатие клавиши Esc во время запроса возвращает null.

let userName = prompt("Кто там?", '');

if (userName === 'Админ') {

  let pass = prompt('Пароль?', '');

  if (pass === 'Я главный') {
    alert( 'Здравствуйте!' );
  } else if (pass === '' || pass === null) {
    alert( 'Отменено' );
  } else {
    alert( 'Неверный пароль' );
  }

} else if (userName === '' || userName === null) {
  alert( 'Отменено' );
} else {
  alert( "Я вас не знаю" );
}


Оператор нулевого слияния ??
значение «определено», если оно не равняется ни null, ни undefined.

Результат выражения a ?? b будет следующим:

если a определено, то a,
если a не определено, то b.
Иначе говоря, оператор ?? возвращает первый аргумент, если он не null/undefined, иначе второй.
result = a ?? b;
result = (a !== null && a !== undefined) ? a : b;

let user;
alert(user ?? "Аноним"); // Аноним (user не существует)

let firstName = null;
let lastName = null;
let nickName = "Суперкодер";
// показывает первое значение, которое определено:
alert(firstName ?? lastName ?? nickName ?? "Аноним"); // Суперкодер

let height = 0;
alert(height || 100); // 100
alert(height ?? 100); // 0

По соображениям безопасности JavaScript запрещает использование оператора ?? вместе с && и ||, если приоритет явно не указан при помощи круглых скобок.

Оператор нулевого присваивания (??=)
let userAge = null;
if (userAge === null || userAge === undefined) {
  userAge = 18;
}
так короче
x ??= y

Задачи
Что выведет код ниже?
alert(undefined ?? NaN ?? null ?? "" ?? " ");
решение
Ответ: NaN. Это первое «определённое» значение.

Что будет выведено в итоге?
let city = null;
city ??= "Берлин";
city ??= null;
city ??= "Кёльн";
city ??= "Гамбург";

alert(city);
решение
Ответ: "Берлин".
Первое присваивание city ??= "Берлин" срабатывает, поскольку изначально city — это null. После присваивания все остальные действия с оператором ??= становятся бессмысленными, так как теперь city содержит «определённое» значение.

Перепишите этот код используя операторы нулевого слияния и присваивания.
let num1 = 10,
    num2 = 20,
    result;
if (result === null || result === undefined) {
  if (num1 !== null && num1 !== undefined) {
    result = num1;
  } else {
    result = num2;
  }
}
решение
let num1 = 10,
    num2 = 20,
    result;
result ??= num1 ?? num2;


Циклы while, do..while, for,
Любое выражение или переменная может быть условием цикла, а не только сравнение: условие while вычисляется и преобразуется в логическое значение.
let i = 3;
while (i) { // когда i будет равно 0, условие станет ложным, и цикл остановится
  alert( i );
  i--;
}

let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);

for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
  alert(i);
}
Выражение инициализации
Выражение условия
Выражение модификации. Выполняется после тела цикла на каждой итерации перед проверкой условия.

Если объявить переменную внутри цикла, то эта переменная будет существовать только внутри цикла. Это встроенное объявление переменной. 
for (let i = 0; i < 3; i++) {
  alert(i); // 0, 1, 2
}
alert(i); // ошибка, нет такой переменной
Вместо объявления новой переменной мы можем использовать уже существующую:

let i = 0;
for (i = 0; i < 3; i++) { // используем существующую переменную
  alert(i); // 0, 1, 2
}
alert(i); // 3, переменная доступна, т.к. была объявлена снаружи цикла


Пропуск частей «for»
let i = 0; // мы уже имеем объявленную i с присвоенным значением
for (; i < 3; i++) { // нет необходимости в "начале"
  alert( i ); // 0, 1, 2
}

let i = 0;
for (; i < 3;) {
  alert( i++ );
}

for (;;) {
  // будет выполняться вечно
}

Прерывание цикла: «break»

код подсчитывает сумму вводимых чисел до тех пор, пока посетитель их вводит, а затем – выдаёт:
let sum = 0;

while (true) {

  let value = +prompt("Введите число", '');

  if (!value) break; // (*)

  sum += value;

}
alert( 'Сумма: ' + sum );
Директива break в строке (*) полностью прекращает выполнение цикла и передаёт управление на строку за его телом

Переход к следующей итерации: continue
for (let i = 0; i < 10; i++) {
  // если true, пропустить оставшуюся часть тела цикла
  if (i % 2 == 0) continue;
  alert(i); // 1, затем 3, 5, 7, 9
}

Нельзя использовать break и continue справа от оператора „?“
(i > 5) ? alert(i) : continue; 
// continue здесь приведёт к ошибке
Потому что break и continue это директивы

Метки для break и continue
Вызов break <name tag break> в цикле ниже ищет ближайший внешний цикл с такой меткой и переходит в его конец.
outer: for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Значение на координатах (${i},${j})`, '');

    // если пустая строка или Отмена, то выйти из обоих циклов
    if (!input) break outer; // (*)

    // сделать что-нибудь со значениями...
  }
}
alert('Готово!');
В примере выше это означает, что вызовом break outer будет разорван внешний цикл до метки с именем outer.
Таким образом управление перейдёт со строки, помеченной (*), к alert('Готово!').

Директива continue также может быть использована с меткой. В этом случае управление перейдёт на следующую итерацию цикла с меткой.
Директива break должна находиться внутри блока кода. Технически, подойдет любой маркированный блок кода

Задачи
Оба цикла выводят alert с одинаковыми значениями или нет?
Префиксный вариант ++i:
let i = 0;
while (++i < 5) alert( i );
Постфиксный вариант i++
let i = 0;
while (i++ < 5) alert( i );
решение
Задача демонстрирует, как постфиксные/префиксные варианты могут повлиять на результат, когда используются в сравнениях.
От 1 до 4
let i = 0;
while (++i < 5) alert( i );
Первое значение: i = 1, так как операция ++i сначала увеличит i, а потом уже произойдёт сравнение и выполнение alert.
Далее 2, 3, 4… Значения выводятся одно за другим. Для каждого значения сначала происходит увеличение, а потом – сравнение, так как ++ стоит перед переменной.
При i = 4 произойдёт увеличение i до 5, а потом сравнение while (5 < 5) – это неверно. Поэтому на этом цикл остановится, и значение 5 выведено не будет.
От 1 до 5
let i = 0;
while (i++ < 5) alert( i );
Первое значение: i = 1. Остановимся на нём подробнее. Оператор i++ увеличивает i, возвращая старое значение, так что в сравнении i++ < 5 будет участвовать i = 0 (в отличие от ++i < 5).
Но последующий вызов alert уже не относится к этому выражению, так что получит новый i = 1.
Далее следуют 2, 3, 4….
Остановимся на i = 4. Префиксная форма ++i увеличила бы i и использовала бы в сравнении 5. Но здесь мы имеем постфиксную форму i++, поэтому она увеличивает i до 5, но возвращает старое значение. Таким образом, сравнение фактически равно while (4 < 5) – true, поэтому срабатывает alert.
Значение i = 5 – последнее, так как на следующем шаге while (5 < 5) – false.

Оба цикла выведут alert с одинаковыми значениями или нет?
Постфиксная форма:
for (let i = 0; i < 5; i++) alert( i );
Префиксная форма:
for (let i = 0; i < 5; ++i) alert( i );
решение
// Ответ: от 0 до 4 в обоих случаях.
for (let i = 0; i < 5; ++i) alert( i );
for (let i = 0; i < 5; i++) alert( i );
Такой результат обусловлен алгоритмом работы for:
Выполнить единожды присваивание i = 0 перед чем-либо (начало).
Проверить условие i < 5
Если true – выполнить тело цикла alert(i), и затем i++
Увеличение i++ выполняется отдельно от проверки условия (2), значение i при этом не используется, поэтому нет никакой разницы между i++ и ++i.

При помощи цикла for выведите чётные числа от 2 до 10.
for (let i = 2; i <= 10; i++) {
  if (i % 2 == 0) {
    alert( i );
  }
}

// Перепишите код, заменив цикл for на while, без изменения поведения цикла.
for (let i = 0; i < 3; i++) {
  alert( `number ${i}!` );
}
решение
let i = 0;
while (i < 3) {
  alert( `number ${i}!` );
  i++;
}

Напишите цикл, который предлагает prompt ввести число, большее 100. Если посетитель ввёл другое число – попросить ввести ещё раз, и так далее.
Цикл должен спрашивать число пока либо посетитель не введёт число, большее 100, либо не нажмёт кнопку Отмена (ESC).
Предполагается, что посетитель вводит только числа. Предусматривать обработку нечисловых строк в этой задаче необязательно.

// мой вариант
let i;
do {
	i = prompt('Введите число > 100', '');
}
while (i !== null && i < 100);
alert(`Ты ввел число ${i}! И это правильный ответ`);


let i=prompt('Введите число > 100', '');

while (i !== null && i <= 100) {
	i=prompt('Давай-ка по-внимательнее прочтем задание');
}
alert(`Ты ввел число ${i}! И это правильный ответ`);




let i = prompt('Введите число > 100', '');

while (i !== null && i <= 100) {
  i = prompt('Давай-ка по-внимательнее прочтем задание');
}

if (i !== null) {
  alert(`Ты ввел число ${i}! И это правильный ответ`);
} else {
  alert('Вы отменили ввод.');
}
// end мой вариант

let num;
do {
  num = prompt("Введите число больше 100?", 0);
} while (num <= 100 && num);

Натуральное число, большее 1, называется простым, если оно ни на что не делится, кроме себя и 1.
Другими словами, n > 1 – простое, если при его делении на любое число кроме 1 и n есть остаток.
Например, 5 это простое число, оно не может быть разделено без остатка на 2, 3 и 4.
Напишите код, который выводит все простые числа из интервала от 2 до n.
Для n = 10 результат должен быть 2,3,5,7.
P.S. Код также должен легко модифицироваться для любых других интервалов.

let n = 10;
nextPrime:
for (let i = 2; i <= n; i++) { // Для всех i...

  for (let j = 2; j < i; j++) { // проверить, делится ли число..
    if (i % j == 0) continue nextPrime; // не подходит, берём следующее
  }
  alert( i ); // простое число
}

Конструкция "switch"
let a = 2 + 2;
switch (a) {
  case 3:
    alert( 'Маловато' );
    break;
  case 4:
    alert( 'В точку!' );
    break;
  case 5:
    alert( 'Перебор' );
    break;
  default:
    alert( "Нет таких значений" );
}

Любое выражение может быть аргументом для switch case
И switch и case допускают любое выражение в качестве аргумента.
let a = "1";
let b = 0;

switch (+a) {
  case b + 1:
    alert("Выполнится, т.к. значением +a будет 1, что в точности равно b+1");
    break;

  default:
    alert("Это не выполнится");
}

Группировка «case»
Теперь оба варианта 3 и 5 выводят одно сообщение.
let a = 3;
switch (a) {
  case 4:
    alert('Правильно!');
    break;
  case 3: // (*) группируем оба case
  case 5:
    alert('Неправильно!');
    alert("Может вам посетить урок математики?");
    break;
  default:
    alert('Результат выглядит странновато. Честно.');
}

В switch проверка на равенство всегда строгая. Значения должны быть одного типа, чтобы выполнялось равенство.
let arg = prompt("Введите число?");
switch (arg) {
  case '0':
  case '1':
    alert( 'Один или ноль' );
    break;
  case '2':
    alert( 'Два' );
    break;

  case 3:
    alert( 'Никогда не выполнится!' );
    break;
  default:
    alert( 'Неизвестное значение' );
}

Задачи
Напишите if..else, соответствующий следующему switch:
switch (browser) {
  case 'Edge':
    alert( "You've got the Edge!" );
    break;
  case 'Chrome':
  case 'Firefox':
  case 'Safari':
  case 'Opera':
    alert( 'Okay we support these browsers too' );
    break;
  default:
    alert( 'We hope that this page looks ok!' );
}
решение
Если совсем точно следовать работе switch, то if должен выполнять строгое сравнение '==='.

Впрочем, для таких строк, подойдёт и обычное сравнение '=='.
if(browser == 'Edge') {
  alert("You've got the Edge!");
} else if (browser == 'Chrome'
 || browser == 'Firefox'
 || browser == 'Safari'
 || browser == 'Opera') {
  alert( 'Okay we support these browsers too' );
} else {
  alert( 'We hope that this page looks ok!' );
}


Перепишите код с использованием одной конструкции switch:
const number = +prompt('Введите число между 0 и 3', '');
if (number === 0) {
  alert('Вы ввели число 0');
}
if (number === 1) {
  alert('Вы ввели число 1');
}
if (number === 2 || number === 3) {
  alert('Вы ввели число 2, а может и 3');
}
решение
Первые две проверки – обычный case, третья разделена на два case:

const number = +prompt('Введите число между 0 и 3', '');
switch (number) {
  case 0:
    alert('Вы ввели число 0');
    break;
  case 1:
    alert('Вы ввели число 1');
    break;
  case 2:
  case 3:
    alert('Вы ввели число 2, а может и 3');
    break;
}

функции
function showMessage() {
  alert( 'Всем привет!' );
}

showMessage();
showMessage();

Локальные переменные
Переменные, объявленные внутри функции, видны только внутри этой функции.
function showMessage() {
  let message = "Привет, я JavaScript!"; // локальная переменная
  alert( message );
}
showMessage(); // Привет, я JavaScript!
alert( message ); // <-- будет ошибка, т.к. переменная видна только внутри функции

У функции есть доступ к внешним переменным, например:
let userName = 'Вася';
function showMessage() {
  let message = 'Привет, ' + userName;
  alert(message);
}
showMessage(); // Привет, Вася

Функция обладает полным доступом к внешним переменным и может изменять их значение.
Например:
let userName = 'Вася';
function showMessage() {
  userName = "Петя"; // (1) изменяем значение внешней переменной
  let message = 'Привет, ' + userName;
  alert(message);
}
alert( userName ); // Вася перед вызовом функции
showMessage();
alert( userName ); // Петя, значение внешней переменной было изменено функцией


Если одноименная переменная объявляется (let, без let берет внешнюю и изменяет ее значение) внутри функции, тогда она перекрывает внешнюю. Внешняя остается неизменной и будет проигнорирована функцией. 
Функция в таком случае создает свою локальную переменную с таким же названием. 
let userName = 'Вася';
function showMessage() {
  let userName = "Петя"; // объявляем локальную переменную

  let message = 'Привет, ' + userName; // Петя
  alert(message);
}
// функция создаст и будет использовать свою собственную локальную переменную userName
showMessage();
alert( userName ); // Вася, не изменилась, функция не трогала внешнюю переменную

Глобальные переменные
Переменные, объявленные снаружи всех функций, такие как внешняя переменная userName в вышеприведённом коде – называются глобальными.
Глобальные переменные видимы для любой функции (если только их не перекрывают одноимённые локальные переменные).
Желательно сводить использование глобальных переменных к минимуму. В современном коде обычно мало или совсем нет глобальных переменных. Хотя они иногда полезны для хранения важнейших «общепроектовых» данных.

Параметры
Мы можем передать внутрь функции любую информацию, используя параметры.

function showMessage(from, text) { // параметры: from, text
  alert(from + ': ' + text);
}

showMessage('Аня', 'Привет!'); // Аня: Привет! (*) А это аргументы
showMessage('Аня', "Как дела?"); // Аня: Как дела? (**) А это аргументы

function showMessage(from, text) {
  from = '*' + from + '*'; // немного украсим "from"
  alert( from + ': ' + text );
}
let from = "Аня";
showMessage(from, "Привет"); // *Аня*: Привет
// значение "from" осталось прежним, функция изменила значение локальной переменной
alert( from ); // Аня

Параметр – это переменная, указанная в круглых скобках в объявлении функции.
Аргумент – это значение, которое передаётся функции при её вызове.

showMessage("Аня");
Это не приведёт к ошибке. Такой вызов выведет "*Аня*: undefined". В вызове не указан параметр text, поэтому предполагается, что text === undefined.
Если при вызове функции аргумент не был указан, то его значением становится undefined.
задать параметру text значение по умолчанию, мы должны указать его после =:
function showMessage(from, text = "текст не добавлен") {
  alert( from + ": " + text );
}
showMessage("Аня"); // Аня: текст не добавлен

function showMessage(from, text = anotherFunction()) {
  // anotherFunction() выполнится только если не передан text
  // результатом будет значение text
}

function showCount(count) {
  // если count равен undefined или null, показать "неизвестно"
  alert(count ?? "неизвестно");
}
showCount(0); // 0
showCount(null); // неизвестно
showCount(); // неизвестно



return Возврат значения 
return производит немедленный выход из функции и возвращает что-либо в код, который функцию вызвал.
Варианты вывода 
1 присваивание перменной + alert
2 alert(sum(1,2))
3 как аргумент в другую функцию 
и тд
Результат функции с пустым return или без него – undefined

function sum(a, b) {
  return a + b;
}
let result = sum(1, 2);
alert( result ); // 3


Директива return может находиться в любом месте тела функции. Как только выполнение доходит до этого места, функция останавливается, и значение возвращается в вызвавший её код (присваивается переменной result выше).

Вызовов return может быть несколько, например:
function checkAge(age) {
  if (age >= 18) {
    return true;
  } else {
    return confirm('А родители разрешили?');
  }
}

let age = prompt('Сколько вам лет?', 18);

if ( checkAge(age) ) {
  alert( 'Доступ получен' );
} else {
  alert( 'Доступ закрыт' );
}

Если мы хотим, чтобы возвращаемое выражение занимало несколько строк, нужно начать его на той же строке, что и return. Или, хотя бы, поставить там открывающую скобку, вот так:
return (
  some + long + expression
  + or +
  whatever * f(a) + f(b)
  )



Этикет программиста в функциях
Выбор имени функции
Функция – это действие. Поэтому имя функции обычно является глаголом. Оно должно быть кратким, точным и описывать действие функции, чтобы программист, который будет читать код, получил верное представление о том, что делает функция.

Как правило, используются глагольные префиксы, обозначающие общий характер действия, после которых следует уточнение. Обычно в командах разработчиков действуют соглашения, касающиеся значений этих префиксов.

Например, функции, начинающиеся с "show" обычно что-то показывают.

Функции, начинающиеся с…

"get…" – возвращают значение,
"calc…" – что-то вычисляют,
"create…" – что-то создают,
"check…" – что-то проверяют и возвращают логическое значение, и т.д.
Примеры таких имён:

showMessage(..)     // показывает сообщение
getAge(..)          // возвращает возраст (получая его каким-то образом)
calcSum(..)         // вычисляет сумму и возвращает результат
createForm(..)      // создаёт форму (и обычно возвращает её)
checkPermission(..) // проверяет доступ, возвращая true/false
Благодаря префиксам, при первом взгляде на имя функции становится понятным, что делает её код, и какое значение она может возвращать.



function showPrimes(n) {
  nextPrime: for (let i = 2; i < n; i++) {

    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }
    alert( i ); // простое
  }
}
Второй вариант использует дополнительную функцию isPrime(n) для проверки на простое:
function showPrimes(n) {

  for (let i = 2; i < n; i++) {
    if (!isPrime(i)) continue;

    alert(i);  // простое
  }
}
function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if ( n % i == 0) return false;
  }
  return true;
}


Одна функция – одно действие
Функция должна делать только то, что явно подразумевается её названием. И это должно быть одним действием.

Два независимых действия обычно подразумевают две функции, даже если предполагается, что они будут вызываться вместе (в этом случае мы можем создать третью функцию, которая будет их вызывать).

Несколько примеров, которые нарушают это правило:

getAge – будет плохим выбором, если функция будет выводить alert с возрастом (должна только возвращать его).
createForm – будет плохим выбором, если функция будет изменять документ, добавляя форму в него (должна только создавать форму и возвращать её).
checkPermission – будет плохим выбором, если функция будет отображать сообщение с текстом доступ разрешён/запрещён (должна только выполнять проверку и возвращать её результат).
В этих примерах использовались общепринятые смыслы префиксов. Конечно, вы в команде можете договориться о других значениях, но обычно они мало отличаются от общепринятых. В любом случае вы и ваша команда должны чётко понимать, что значит префикс, что функция с ним может делать, а чего не может.

Сверхкороткие имена функций
Имена функций, которые используются очень часто, иногда делают сверхкороткими.

Например, фреймворк jQuery определяет функцию с помощью $. В библиотеке Lodash основная функция представлена именем _.

Это исключения. В основном имена функций должны быть в меру краткими и описательными.


Задачи
Перепишите функцию, чтобы она делала то же самое, но без if, в одну строку.
Сделайте два варианта функции checkAge:
Используя оператор ?
Используя оператор ||
решение
Используя оператор ?:
function checkAge(age) {
  return (age > 18) ? true : confirm('Родители разрешили?');
}
Используя оператор || (самый короткий вариант):
function checkAge(age) {
  return (age > 18) || confirm('Родители разрешили?');
}
Обратите внимание, что круглые скобки вокруг age > 18 не обязательны. Они здесь для лучшей читаемости кода.


Написать функцию, которая возвращает меньшее из двух чисел

let min_a = +prompt('Введите число №1', ' ');
let min_b = +prompt('Введите число №2', ' ');
function minNumber(num_a, num_b) {
	return (num_a < num_b) ? `Число ${num_a} > числа ${min_b}` : num_b;
}
alert(minNumber(min_a, min_b));

Напишите функцию pow(x,n), которая возводит x в степень n и возвращает результат.
pow(3, 2) = 3 * 3 = 9
pow(3, 3) = 3 * 3 * 3 = 27
pow(1, 100) = 1 * 1 * ...* 1 = 1

P.S. В этой задаче функция обязана поддерживать только натуральные значения n, т.е. целые от 1 и выше.
let num_exp_1 = +prompt('Введите число, которое будет возведено в степень', '4');
let num_exp_2 = +prompt('Введите степень', '2');

function exponentiation(num_exp_1, num_exp_2) {
	return `Число ${num_exp_1}, возведенное в степень ${num_exp_2} = ${num_exp_1 ** num_exp_2}`;
}
alert(exponentiation(num_exp_1, num_exp_2));


let num_exp_1 = +prompt('Введите число, которое будет возведено в степень', '4');
let num_exp_2 = +prompt('Введите степень', '2');

function exponentiation(num_exp_1, num_exp_2) {
	if (Number(num_exp_1) && Number(num_exp_2)) {
		return `Число ${num_exp_1}, возведенное в степень ${num_exp_2} = ${num_exp_1 ** num_exp_2}`;
	} else {
		alert('Нужны числа, а не буквы!');
	}
}
	if (exponentiation(num_exp_1, num_exp_2)) {
		alert(exponentiation(num_exp_1, num_exp_2));	
	} 

правильный вариант 
function pow(x, n) {
  let result = x;

  for (let i = 1; i < n; i++) {
    result *= x;
  }

  return result;
}

let x = prompt("x?", '');
let n = prompt("n?", '');

if (n >= 1 && n % 1 == 0) {
  alert( pow(x, n) );
} else {
  alert(`Степень ${n} не поддерживается, используйте натуральное число`);
}


Function Declaration (Объявление Функции)
Function Expression
Синтаксис создания функции
function expression позволяет создавать новую функцию в середние любого выражения.
let sayHi = function() {
  alert( "Привет" );
};
function expression допускает объявление функции без имени.
С помощью данного синтаксиса функция становится анонимной и нигде не сохраняется.

Важное правило: независимо от того как создается функция, она является значением
function sayHi() {
  alert( "Привет" );
}
alert( sayHi ); // выведет код функции
последняя строка не вызывает функцию, потому что после sayHi нет круглых скобок.

function sayHi() {   // (1) создаём
  alert( "Привет" );
}
let func = sayHi;    // (2) копируем
func(); // Привет     // (3) вызываем копию (работает)!
sayHi(); // Привет    //     эта тоже все ещё работает (почему бы и нет)
Давайте подробно разберём всё, что тут произошло:
Объявление Function Declaration (1) создаёт функцию и помещает её в переменную с именем sayHi.
В строке (2) мы скопировали её значение в переменную func. Обратите внимание (ещё раз): нет круглых скобок после sayHi. Если бы они были, то выражение func = sayHi() записало бы результат вызова sayHi() в переменную func, а не саму функцию sayHi.
Теперь функция может вызываться как sayHi(), так и func().
Мы также могли бы использовать Function Expression для объявления sayHi в первой строке:
let sayHi = function() { // (1) создаём
  alert( "Привет" );
};
let func = sayHi;
// ...

Точку с запятой ; рекомендуется ставить в конце выражения, она не является частью синтаксиса функции.
Точка с запятой нужна там для более простого присваивания, такого как let sayHi = 5;, а также для присваивания функции.


Функции-«колбэки»

function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}
function showOk() {
  alert( "Вы согласны." );
}
function showCancel() {
  alert( "Вы отменили выполнение." );
}
// использование: функции showOk, showCancel передаются в качестве аргументов ask
ask("Вы согласны?", showOk, showCancel);

используя Function Expression:
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Вы согласны?",
  function() { alert("Вы согласились."); },
  function() { alert("Вы отменили выполнение."); }
);
Функция, которая используется в аргументе другой функции. называется колбэк.

Параметрами функции могут быть друие функции как внутренние так и внешние.

Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.
После того, как поток выполнения достигнет правой части выражения присваивания let sum = function… – с этого момента, функция считается созданной и может быть использована (присвоена переменной, вызвана и т.д. ).

Function Declaration может быть вызвана раньше, чем она объявлена.
Когда движок JavaScript готовится выполнять скрипт или блок кода, прежде всего он ищет в нём Function Declaration и создаёт все такие функции.

sayHi("Вася"); // Привет, Вася

function sayHi(name) {
  alert( `Привет, ${name}` );
}

sayHi("Вася"); // ошибка!

let sayHi = function(name) {  // (*) магии больше нет
  alert( `Привет, ${name}` );
};



Важная особенность Function Declaration заключается в их блочной области видимости в отличие от function expression
В строгом режиме, когда Function Declaration находится в блоке {...}, функция доступна везде внутри блока. Но не снаружи него.

let age = prompt("Сколько Вам лет?", 18);
// в зависимости от условия объявляем функцию
if (age < 18) {
  function welcome() {
    alert("Привет!");
  }
} else {
  function welcome() {
    alert("Здравствуйте!");
  }
}
// ...не работает
welcome(); // Error: welcome is not defined
еще пример
let age = 16; // возьмём для примера 16

if (age < 18) {
  welcome();               // \   (выполнится)
                           //  |
  function welcome() {     //  |
    alert("Привет!");      //  |  Function Declaration доступно
  }                        //  |  во всём блоке кода, в котором объявлено
                           //  |
  welcome();               // /   (выполнится)

} else {

  function welcome() {
    alert("Здравствуйте!");
  }
}
// здесь фигурная скобка закрывается,
// поэтому Function Declaration, созданные внутри блока кода выше -- недоступны отсюда.
welcome(); // Ошибка: welcome is not defined

Можно воспользоваться функцией, объявленной при помощи Function Expression, и присвоить значение welcome переменной, объявленной снаружи if, что обеспечит нам нужную видимость.

let age = prompt("Сколько Вам лет?", 18);

let welcome;
if (age < 18) {
  welcome = function() {
    alert("Привет!");
  };
} else {
  welcome = function() {
    alert("Здравствуйте!");
  };

}
welcome(); // теперь всё в порядке
чище и правильнее
let age = prompt("Сколько Вам лет?", 18);

let welcome = (age < 18) ?
  function() { alert("Привет!"); } :
  function() { alert("Здравствуйте!"); };

welcome(); // теперь всё в порядке

Когда использовать Function Declaration, а когда Function Expression?
Как правило, если нам понадобилась функция, в первую очередь нужно рассматривать синтаксис Function Declaration, который мы использовали до этого. Он даёт нам больше свободы в том, как мы можем организовывать код. Функции, объявленные таким образом, можно вызывать до их объявления.


Стрелочные функции, основы. Еще один способ исползования функций
arrow functions Это functions expression только в короткой форме

Это создаёт функцию func, которая принимает аргументы arg1..argN, затем вычисляет expression в правой части с их использованием и возвращает результат.
все, что находится после стрелки это return
let func = (arg1, arg2, ...argN) => expression;
сокращённая версия кода выше:
let func = function(arg1, arg2, ...argN) {
  return expression;
};

let sum = (a, b) => a + b;
/* Эта стрелочная функция представляет собой более короткую форму:
let sum = function(a, b) {
  return a + b;
};
*/
alert( sum(1, 2) ); // 3

Если только один аргумент, то круглые скобки вокруг параметров можно опустить
let double = n => n * 2;
// примерно то же, что и: let double = function(n) { return n * 2 }
alert( double(3) ); // 6
Если аргументов нет, круглые скобки будут пустыми, но они должны присутствовать:
let sayHi = () => alert("Hello!");
sayHi();

Можно использовать так же как и function expression для динамического создания функции
let age = prompt("Сколько Вам лет?", 18);
let welcome = (age < 18) ?
  () => alert('Привет!') :
  () => alert("Здравствуйте!");
welcome();


Многострочные стрелочные функции
Тоже самое как и arrow functions, но с возможностью делать более сложные инструкции и выражения в {}
Требует явно указать return.
let sum = (a, b) => {  // фигурная скобка, открывающая тело многострочной функции
  let result = a + b;
  return result; // если мы используем фигурные скобки, то нам нужно явно указать "return"
};
alert( sum(1, 2) ); // 3



Задачи
Замените код Function Expression стрелочной функцией:
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}
ask(
  "Вы согласны?",
  function() { alert("Вы согласились."); },
  function() { alert("Вы отменили выполнение."); }
);

ответ
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}
ask(
  "Вы согласны?",
  () => alert("Вы согласились."),
  () => alert("Вы отменили выполнение.")
);



















































































































