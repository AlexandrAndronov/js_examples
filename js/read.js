Создал язык Брендо Эйк 1995
Js –– это интерпретируемый язык, компиллируемый в реальном времени через jit (just in time)
С var – обычная переменная, без var – глобальная. let – более современный вариант объявления переменной.
Области видимости: глобальная и локальная. 
'use strict' – строгий режим, код получается более чистый и безопасный. Многие современные фичи и функции работают в этом режиме по умолчанию.
Первый символ в переменной не должен быть цифрой. Допустимы символы в названии переменной $, _ .
Переменные чувствительны к регистру.
Разрешены нелатинские буквы, но не рекомендуются.
Без 'use strict' можно объявить переменную обычным присваиванием без let, но не рекомендуется.
Повторное объявление вызывает ошибку. Переменная может быть объявлена только один раз. Поэтому следует объявлять переменную только один раз и затем использовать её уже без let.
Существует список зарезервированных слов, которые нельзя использовать в качестве имён переменных, потому что они используются самим языком.
Константы с именами, записанными заглавными буквами, используются только как псевдонимы для «жёстко закодированных» значений.
Константа может быть инициализированна результатом какого-либо выражения, но значение должно быть присвоено сразу.
Двойные или одинарные кавычки являются «простыми», между ними нет разницы в JavaScript.
Обратные же кавычки имеют расширенную функциональность. Они позволяют нам встраивать выражения в строку, заключая их в ${…}. Например:
Математические операции в JavaScript «безопасны». Мы можем делать что угодно: делить на ноль, обращаться с нечисловыми строками как с числами и т.д.
Скрипт никогда не остановится с фатальной ошибкой (не «умрёт»). В худшем случае мы получим NaN как результат выполнения.



Зарезервированные ключевые слова в ECMAScript 2015
break
case
class
catch
const
continue
debugger
default
delete
do
else
export
extends
finally
for
function
if
import
in
instanceof
let
new
return
super
switch
this
throw
try
typeof
var
void
while
with
yield







Объявление переменных

let message;
message = 'Hello!';

alert(message); // показывает содержимое переменной



let message = 'Hello!'; // определяем переменную и присваиваем ей значение

alert(message); // Hello!


let user = 'John', age = 25, message = 'Hello';



let user = 'John';
let age = 25;
let message = 'Hello';


let user = 'John',
  age = 25,
  message = 'Hello';



let hello = 'Hello world!';

let message;

// копируем значение 'Hello world' из переменной hello в переменную message
message = hello;

// теперь две переменные содержат одинаковые данные
alert(hello); // Hello world!
alert(message); // Hello world!




Константы


const myBirthday = '18.04.1982';

Переменные, объявленные с помощью const, называются «константами». Их нельзя изменить. Попытка сделать это приведёт к ошибке:
const myBirthday = '18.04.1982';
myBirthday = '01.01.2001'; // ошибка, константу нельзя перезаписать!





Константы в верхнем регистре
Широко распространена практика использования констант в качестве псевдонимов для трудно запоминаемых значений, которые известны до начала исполнения скрипта.
const COLOR_RED = "#F00";
const COLOR_GREEN = "#0F0";
const COLOR_BLUE = "#00F";
const COLOR_ORANGE = "#FF7F00";

// ...когда нам нужно выбрать цвет
let color = COLOR_ORANGE;
alert(color); // #FF7F00

константы с именами, записанными заглавными буквами, используются только как псевдонимы для «жёстко закодированных» значений.




Типы данных

Js – динамически типизированный язык и переменные не привязаны к типам данных.
// Не будет ошибкой
let message = "hello";
message = 123456;

числа
Infinity представляет собой математическую бесконечность ∞. Это особое значение, которое больше любого числа.
Мы можем получить его в результате деления на ноль
NaN означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции, например:
Значение NaN «прилипчиво». Любая математическая операция с NaN возвращает NaN. (есть только одно исключение: NaN ** 0 равно 1).


В JavaScript есть 8 основных типов данных.

Семь из них называют «примитивными» типами данных:
number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).
bigint для целых чисел произвольной длины.
string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
boolean для true/false.
null представляет собой «ничего», «пусто» или «значение неизвестно».
undefined Специальное значение undefined также стоит особняком. Оно формирует тип из самого себя так же, как и null.
Оно означает, что «значение не было присвоено».
Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет undefined
Обычно null используется для присвоения переменной «пустого» или «неизвестного» значения, а undefined – для проверок, была ли переменная назначена.
symbol для уникальных идентификаторов.
И один не является «примитивным» и стоит особняком:
object для более сложных структур данных.

typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"  (1)

typeof null // "object"  (2)

typeof alert // "function"  (3)

BigInt
let n = (20 ** 20);
alert(typeof n);
alert (n);

// символ "n" в конце означает, что это BigInt
const bigInt = 1234567890123456789012345678901234567890n;



alert, prompt, confirm

alert
показывает сообщение.
prompt
показывает сообщение и запрашивает ввод текста от пользователя. Возвращает напечатанный в поле ввода текст или null, если была нажата кнопка «Отмена» или Esc с клавиатуры.
confirm
показывает сообщение и ждёт, пока пользователь нажмёт OK или Отмена. Возвращает true, если нажата OK, и false, если нажата кнопка «Отмена» или Esc с клавиатуры.
Все эти методы являются модальными: останавливают выполнение скриптов и не позволяют пользователю взаимодействовать с остальной частью страницы до тех пор, пока окно не будет закрыто.

На все указанные методы распространяются два ограничения:

Расположение окон определяется браузером. Обычно окна находятся в центре.
Визуальное отображение окон зависит от браузера, и мы не можем изменить их вид.




Преобразование типов

Чаще всего операторы и функции автоматически приводят переданные им значения к нужному типу.
Например, alert автоматически преобразует любое значение к строке. Математические операторы преобразуют значения к числам.

Строковое преобразование
Строковое преобразование происходит, когда требуется представление чего-либо в виде строки.

Например, alert(value) преобразует значение к строке.

Также мы можем использовать функцию String(value), чтобы преобразовать значение к строке:

let value = true;
alert(typeof value); // boolean

value = String(value); // теперь value это строка "true"
alert(typeof value); // string
Преобразование происходит очевидным образом. false становится "false", null становится "null" и т.п.


Численное преобразование
Численное преобразование происходит в математических функциях и выражениях.

Например, когда операция деления / применяется не к числу:

alert( "6" / "2" ); // 3, строки преобразуются в числа
Мы можем использовать функцию Number(value), чтобы явно преобразовать value к числу:

let str = "123";
alert(typeof str); // string

let num = Number(str); // становится числом 123

alert(typeof num); // number
Явное преобразование часто применяется, когда мы ожидаем получить число из строкового контекста, например из текстовых полей форм.

Если строка не может быть явно приведена к числу, то результатом преобразования будет NaN. Например:

let age = Number("Любая строка вместо числа");

alert(age); // NaN, преобразование не удалось
Правила численного преобразования:

Значение	Преобразуется в…
undefined	NaN
null	0
true / false	1 / 0
string	Пробельные символы (пробелы, знаки табуляции \t, знаки новой строки \n и т. п.) по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.
Примеры:

alert( Number("   123   ") ); // 123
alert( Number("123z") );      // NaN (ошибка чтения числа на месте символа "z")
alert( Number(true) );        // 1
alert( Number(false) );       // 0

null и undefined ведут себя по-разному. Так, null становится нулём, тогда как undefined приводится к NaN.


Логическое преобразование

Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false.
Все остальные значения становятся true.
alert( Boolean(1) ); // true
alert( Boolean(0) ); // false

alert( Boolean("Привет!") ); // true
alert( Boolean("") ); // false

alert( Boolean("0") ); // true
alert( Boolean(" ") ); // пробел это тоже true (любая непустая строка это true)




let age = prompt('Сколько тебе лет?', 100);
alert(`Тебе ${age} лет!`);



 let name = "Ilya";

alert( `hello ${1}` ); // ?

alert( `hello ${"name"}` ); // ?

alert( `hello ${name}` ); // ?»


let isBoss = confirm("Ты здесь главный?");
alert(isBoss);


let currentUserName = prompt('Как тебя зовут?', "");
alert(`Его имя – ${currentUserName}`);



Базовые операторы
Термины: «унарный», «бинарный», «операнд»
Операнд – то, к чему применяется оператор. Например, в умножении 5 * 2 есть два операнда: левый операнд равен 5, а правый операнд равен 2. Иногда их называют «аргументами» вместо «операндов».
Унарным называется оператор, который применяется к одному операнду. Например, оператор унарный минус "-" меняет знак числа на противоположный:

let x = 1;

x = -x;
alert( x ); // -1, применили унарный минус
Бинарным называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме:

let x = 1, y = 3;
alert( y - x ); // 2, бинарный минус вычитает значения

alert( 5 % 2 ); // 1, остаток от деления 5 на 2
alert( 8 % 3 ); // 2, остаток от деления 8 на 3
alert( 8 % 4 ); // 0, остаток от деления 8 на 4
Возведение в степень **
Оператор возведения в степень a ** b возводит a в степень b.


Сложение строк при помощи бинарного +
let s = "моя" + "строка";
alert(s); // моястрока
Обратите внимание, если хотя бы один операнд является строкой, то второй будет также преобразован в строку.
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
alert(2 + 2 + '1' ); // будет "41", а не "221"

Сложение и преобразование строк — это особенность бинарного плюса +. Только + может работать со строками. Другие арифметические операторы работают только с числами и всегда преобразуют операнды в числа.
Если операнд не число, унарный плюс преобразует его в число.
// Не влияет на числа
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

// Преобразует не числа в числа
alert( +true ); // 1
alert( +"" );   // 0
это то же самое, что и Number(...), только короче.
let apples = "2";
let oranges = "3";

alert( apples + oranges ); // "23", так как бинарный плюс объединяет строки
Поэтому используем унарный плюс, чтобы преобразовать к числу:

let apples = "2";
let oranges = "3";

// оба операнда предварительно преобразованы в числа
alert( +apples + +oranges ); // 5

// более длинный вариант
// alert( Number(apples) + Number(oranges) ); // 5

Приоритет	Тип оператора	Ассоциативность	Конкретные операторы
18	Группировка	не определено	( … )
17	Доступ к свойствам	слева направо	… . …
Доступ к свойствам с возможностью вычисления	… [ … ]
new (со списком аргументов)	не определено	new … ( … )
Вызов функции	слева направо	… ( … )
Оператор опциональной последовательности (?.)	?.
16	new (без списка аргументов)	справа налево	new …
15	Постфиксный инкремент	не определено	… ++
Постфиксный декремент	… --
14	Логическое отрицание (!)	справа налево	! …
Побитовое отрицание (~)	~ …
Унарный плюс	+ …
Унарный минус	- …
Префиксный инкремент	++ …
Префиксный декремент	-- …
typeof	typeof …
void	void …
delete	delete …
await	await …
13	Возведение в степень (**)	справа налево	… ** …
12	Умножение (*)	слева направо	… * …
Деление (/)	… / …
Остаток от деления (%)	… % …
11	Сложение (+)	слева направо	… + …
Вычитание (-)	… - …
10	Побитовый сдвиг влево (<<)	слева направо	… << …
Побитовый сдвиг вправо (>>)	… >> …
Сдвиг вправо с заполнением нулей (>>>)	… >>> …
9	Меньше (<)	слева направо	… < …
Меньше или равно (<=)	… <= …
Больше (>)	… > …
Больше или равно (>=)	… >= …
in	… in …
instanceof	… instanceof …
8	Равенство (==)	слева направо	… == …
Неравенство (!=)	… != …
Строгое равенство (===)	… === …
Строгое неравенство (!==)	… !== …
7	Побитовое «И» (&)	слева направо	… & …
6	Побитовое исключающее «ИЛИ» (^)	слева направо	… ^ …
5	Побитовое «ИЛИ» (|)	слева направо	… | …
4	Логическое «И» (&&)	слева направо	… && …
3	Логическое «ИЛИ» (||)	слева направо	… || …
Оператор нулевого слияния (??)	… ?? …
2	Присваивание	справа налево	… = …
… += …
… -= …
… **= …
… *= …
… /= …
… %= …
… <<= …
… >>= …
… >>>= …
… &= …
… ^= …
… |= …
… &&= …
… ||= …
… ??= …
Условный (тернарный) оператор	справа налево	… ? … : …
yield	справа налево	yield …
yield*	yield* …
1	Запятая / Последовательность	слева направо	… , …


Инкремент/декремент
Инкремент/декремент можно применить только к переменной. Попытка использовать его на значении, типа 5++, приведёт к ошибке.
let counter = 1;
let a = ++counter; // (*)

alert(a); // 2
В строке (*) префиксная форма ++counter увеличивает counter и возвращает новое значение 2. Так что alert покажет 2.

Теперь посмотрим на постфиксную форму:

let counter = 1;
let a = counter++; // (*) меняем ++counter на counter++

alert(a); // 1
В строке (*) постфиксная форма counter++ также увеличивает counter, но возвращает старое значение (которое было до увеличения). Так что alert покажет 1.
Операторы ++/-- могут также использоваться внутри выражений. Их приоритет выше, чем у большинства других арифметических операций.

let a = 1, b = 1;

let c = ++a; // ?
let d = b++; // ?
Ответ:

a = 2
b = 2
c = 2
d = 1
let a = 1, b = 1;

alert( ++a ); // 2, префиксная форма возвращает новое значение
alert( b++ ); // 1, постфиксная форма возвращает старое значение

alert( a ); // 2, значение увеличено один раз
alert( b ); // 2, значение увеличено один раз


Побитовые операторы
Побитовые операторы работают с 32-разрядными целыми числами (при необходимости приводят к ним), на уровне их внутреннего двоичного представления.

Эти операторы не являются чем-то специфичным для JavaScript, они поддерживаются в большинстве языков программирования.

Поддерживаются следующие побитовые операторы:

AND(и) ( & )
OR(или) ( | )
XOR(побитовое исключающее или) ( ^ )
NOT(не) ( ~ )
LEFT SHIFT(левый сдвиг) ( << )
RIGHT SHIFT(правый сдвиг) ( >> )
ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( >>> )
Они используются редко, когда возникает необходимость оперировать с числами на очень низком (побитовом) уровне. В ближайшем времени они нам не понадобятся, так как веб-разработчики редко к ним прибегают, хотя в некоторых сферах (например, в криптографии) они полезны


задачи
"" + 1 + 0 = "10" // (1)
"" - 1 + 0 = -1 // (2)
true + false = 1
6 / "3" = 2
"2" * "3" = 6
4 + 5 + "px" = "9px"
"$" + 4 + 5 = "$45"
"4" - 2 = 2
"4px" - 2 = NaN
"  -9  " + 5 = "  -9  5" // (3)
"  -9  " - 5 = -14 // (4)
null + 1 = 1 // (5)
undefined + 1 = NaN // (6)
" \t \n" - 2 = -2 // (7)
Сложение со строкой "" + 1 преобразует 1 к строке: "" + 1 = "1", и в следующем случае "1" + 0 работает то же самое правило.
Вычитание - (как и большинство математических операторов) работает только с числами, пустая строка "" приводится к 0.
Сложение со строкой превращает число 5 в строку и добавляет к строке.
Вычитание всегда преобразует к числу, значит строка " -9 " становится числом -9 (пробелы по краям обрезаются).
null становится 0 после численного преобразования.
undefined становится NaN после численного преобразования.
Пробельные символы, такие как \t и \n, по краям строки игнорируются при преобразовании в число, так что строка " \t \n", аналогично пустой строке, становится 0 после численного преобразования.



Сравнения
alert( 2 > 1 );  // true (верно)
alert( 2 == 1 ); // false (неверно)
alert( 2 != 1 ); // true (верно)
Сравнение строк
Чтобы определить, что одна строка больше другой, JavaScript использует «алфавитный» или «лексикографический» порядок.
Используется кодировка Unicode, а не настоящий алфавит
Приведённый выше алгоритм сравнения похож на алгоритм, используемый в словарях и телефонных книгах, но между ними есть и различия.
Например, в JavaScript имеет значение регистр символов. Заглавная буква "A" не равна строчной "a". Какая же из них больше? Строчная "a". Почему? Потому что строчные буквы имеют больший код во внутренней таблице кодирования, которую использует JavaScript (Unicode).


Сравнение разных типов
При сравнении значений разных типов JavaScript приводит каждое из них к числу.

Например:

alert( '2' > 1 ); // true, строка '2' становится числом 2
alert( '01' == 1 ); // true, строка '01' становится числом 1

Логическое значение true становится 1, а false – 0.
Например:

alert( true == 1 ); // true
alert( false == 0 ); // true

let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true строка не пустая

alert(a == b); // true!
С точки зрения JavaScript, результат ожидаем. Равенство преобразует значения, используя числовое преобразование, поэтому "0" становится 0. В то время как явное преобразование с помощью Boolean использует другой набор правил.


Строгое сравнение
Использование обычного сравнения == может вызывать проблемы. Например, оно не отличает 0 от false:
alert( 0 == false ); // true
Та же проблема с пустой строкой:
alert( '' == false ); // true

alert( 0 === false ); // false, так как сравниваются разные типы
оператор строгого неравенства !==


Сравнение с null и undefined
Поведение null и undefined при сравнении с другими значениями — особое:

При строгом равенстве ===
Эти значения различны, так как различны их типы.

alert( null === undefined ); // false
При нестрогом равенстве ==
Эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.

alert( null == undefined ); // true

При использовании математических операторов и других операторов сравнения < > <= >=
Значения null/undefined преобразуются к числам: null становится 0, а undefined – NaN.
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true

Значение undefined несравнимо с другими значениями.
undefined всегда преобразуется в NaN.

alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)

задачи
5 > 4 → true
"ананас" > "яблоко" → false
"2" > "12" → true
undefined == null → true
undefined === null → false
null == "\n0\n" → false
null === +"\n0\n" → false
Разъяснения:

Очевидно, true.
Используется посимвольное сравнение, поэтому false. "а" меньше, чем "я".
Снова посимвольное сравнение. Первый символ первой строки "2" больше, чем первый символ второй "1".
Специальный случай. Значения null и undefined равны только друг другу при нестрогом сравнении.
Строгое сравнение разных типов, поэтому false.
Аналогично (4), null равен только undefined.
Строгое сравнение разных типов.



Условие if
let accessAllowed;
let age = prompt('Сколько вам лет?', '');

if (age > 18) {
  accessAllowed = true;
} else {
  accessAllowed = false;
}
alert(accessAllowed);

тернарный оператор:
let result = условие ? значение1 : значение2;
let accessAllowed = (age > 18) ? true : false;
// оператор сравнения "age > 18" выполняется первым в любом случае
// (нет необходимости заключать его в скобки)
let accessAllowed = age > 18 ? true : false;


let age = prompt('Возраст?', 18);

let message = (age < 3) ? 'Здравствуй, малыш!' :
  (age < 18) ? 'Привет!' :
  (age < 100) ? 'Здравствуйте!' :
  'Какой необычный возраст!';
alert( message );


задачи
if ("0") {
  alert( 'Привет' );//true
}




let a = prompt('Первое число', 1);
let b = prompt('Второе число', 2);

alert(+a + +b);



let questionNameJs = prompt('Какое правильное название JavaScript?', "");

if (questionNameJs == 'ECMAScript') {
	alert('Верно!');
} else {
	alert('Неа(');
}




let userValue = prompt('Введите какое-либо значение', '0');

if (userValue > 0) {
	alert(+1);
} else if (userValue == 0) {
	alert('значение равно нулу');
} else {
	alert(-1);
}



if (1 && 0) {
	alert('Это не должно быть выведено на экран');
}









let height = null;
let width = null;
// ...сработает вот так (совсем не как нам нужно):
let area = height ?? (100 * width) ?? 50;



let i = 0;
while (i < 3) {
	alert(i);
	i++;
}


let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);


let i = 0;

for (; i < 3;) {
  alert( i++ );
}




for (let i=2; i <= 10; i++) {
	if (i % 2 == 0) {
	alert(i);
  }
}




Задание: Напишите цикл, который предлагает prompt ввести число, большее 100. Если посетитель ввёл другое число – попросить ввести ещё раз, и так далее.

Цикл должен спрашивать число пока либо посетитель не введёт число, большее 100, либо не нажмёт кнопку Отмена (ESC).

Предполагается, что посетитель вводит только числа. Предусматривать обработку нечисловых строк в этой задаче необязательно.


let i;
do {
	i = prompt('Введите число > 100', '');
}
while (i !== null && i < 100);
alert(`Ты ввел число ${i}! И это правильный ответ`);


let i=prompt('Введите число > 100', '');

while (i !== null && i <= 100) {
	i=prompt('Давай-ка по-внимательнее прочтем задание');
}
alert(`Ты ввел число ${i}! И это правильный ответ`);




let i = prompt('Введите число > 100', '');

while (i !== null && i <= 100) {
  i = prompt('Давай-ка по-внимательнее прочтем задание');
}

if (i !== null) {
  alert(`Ты ввел число ${i}! И это правильный ответ`);
} else {
  alert('Вы отменили ввод.');
}





Вывести простые числа
let n = 100;
nextPrime:
for (let i = 2; i <= n; i++) {
	for (let j = 2; j < i; j++) {
		if (i % j === 0) continue nextPrime;
	}
	alert(i);
}





let arg = prompt("Введите число?");
switch (arg) {
  case '0':
  case '1':
    alert( 'Один или ноль' );
    break;

  case '2':
    alert( 'Два' );
    break;

  case 3:
    alert( 'Никогда не выполнится!' );
    break;
  default:
    alert( 'Неизвестное значение' );
}




let userName = "Василий";

function showMessage() {
 let message = "Hello, my dear " + userName + '!';

	alert(message);
}
showMessage();




let userName = 'Василий';

function showMessage() {
	let userName = 'Петр';
	let message = 'Привет, ' + userName + '!';
	alert(message);
}

showMessage();
alert(userName);



function sum(a, b) {
  return a + b;
}
let result = sum(1, 2);
alert( result );


Пример 22
function checkAge(age) {
  if (age >= 18) {
    return true;
  } else {
    return confirm('А родители разрешили?');
  }
}

let age = prompt('Сколько вам лет?', 18);

if ( checkAge(age) ) {
  alert( 'Доступ получен' );
} else {
  alert( 'Доступ закрыт' );
}


Пример 23
function showMovie(age) {
  if ( !checkAge(age) ) {
    return;
  }

  alert( "Вам показывается кино" ); // (*)
  // ...
}






function showPrimes(n) {
  nextPrime: for (let i = 2; i < n; i++) {

    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert( i ); // простое
  }
}
Второй вариант использует дополнительную функцию isPrime(n) для проверки на простое:

function showPrimes(n) {

  for (let i = 2; i < n; i++) {
    if (!isPrime(i)) continue;

    alert(i);  // простое
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if ( n % i == 0) return false;
  }
  return true;
}









Перепишите функцию, используя оператор '?' или '||'
важность: 4
Следующая функция возвращает true, если параметр age больше 18.

В ином случае она задаёт вопрос confirm и возвращает его результат.

function checkAge(age) {
  if (age > 18) {
    return true;
  } else {
    return confirm('Родители разрешили?');
  }
}
Перепишите функцию, чтобы она делала то же самое, но без if, в одну строку.

Сделайте два варианта функции checkAge:

Используя оператор ?
Используя оператор ||


let age = prompt('How older you?');
function checkAge(age) {
	return (age > 18) ? alert('Добро пожаловать!') : confirm('Родители-то разрешили?');
}

checkAge(age);


let age = prompt('How older you?');

function checkAge(age) {
	return (age > 18) || confirm('Родители разрешили?');
}







Написать функцию, которая возвращает меньшее из двух чисел

let min_a = +prompt('Введите число №1', ' ');
let min_b = +prompt('Введите число №2', ' ');

function minNumber(num_a, num_b) {
	return (num_a < num_b) ? `Число ${num_a} > числа ${min_b}` : num_b;
}

alert(minNumber(min_a, min_b));


let num_exp_1 = +prompt('Введите число, которое будет возведено в степень', '4');
let num_exp_2 = +prompt('Введите степень', '2');

function exponentiation(num_exp_1, num_exp_2) {
	return `Число ${num_exp_1}, возведенное в степень ${num_exp_2} = ${num_exp_1 ** num_exp_2}`;
}

alert(exponentiation(num_exp_1, num_exp_2));



let num_exp_1 = +prompt('Введите число, которое будет возведено в степень', '4');
let num_exp_2 = +prompt('Введите степень', '2');

function exponentiation(num_exp_1, num_exp_2) {
	if (Number(num_exp_1) && Number(num_exp_2)) {
		return `Число ${num_exp_1}, возведенное в степень ${num_exp_2} = ${num_exp_1 ** num_exp_2}`;
	} else {
		alert('Нужны числа, а не буквы!');
	}
}

	if (exponentiation(num_exp_1, num_exp_2)) {
		alert(exponentiation(num_exp_1, num_exp_2));	
	} 



function pow(x, n) {
  let result = x;

  for (let i = 1; i < n; i++) {
    result *= x;
  }

  return result;
}

let x = prompt("x?", '');
let n = prompt("n?", '');

if (n >= 1 && n % 1 == 0) {
  alert( pow(x, n) );
} else {
  alert(`Степень ${n} не поддерживается, используйте натуральное число`);
}





function sayHi() {
	alert('Hi');
}

let function_link = sayHi;

sayHi();
function_link();




Пример 25
function ask(question, yes, no) {
	if (confirm(question)) {
		yes();
	} else {
		no();
	}
}

function showOk() {
	alert('Вы дали согласие!');
}

function showCancel() {
	alert('Вы не согласны!');
}

ask('Вы согласны?', showOk, showCancel);





Пример 25_1
function ask(question, yes, no) {
	if (confirm(question)) {
		yes();
	} else {
		no();
	}
}

ask('Вы даете свое согласие?',
	function() { alert('Вы дали свое согласие!'); },
	function() { alert('Вы не дали свое согласие!'); }
	);


























































































































